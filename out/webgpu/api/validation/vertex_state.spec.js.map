{"version":3,"sources":["../../../../src/webgpu/api/validation/vertex_state.spec.ts"],"names":["description","params","pbool","poptions","makeTestGroup","kMaxVertexAttributes","kMaxVertexBufferArrayStride","kMaxVertexBuffers","kVertexFormats","kVertexFormatInfo","ValidationTest","VERTEX_SHADER_CODE_WITH_NO_INPUT","addTestAttributes","attributes","testAttribute","testAttributeAtStart","extraAttributeCount","extraAttributeSkippedLocations","currentLocation","extraAttribsAdded","includes","push","format","shaderLocation","offset","unshift","F","getDescriptor","vertexState","vertexShaderCode","descriptor","vertexStage","module","device","createShaderModule","code","entryPoint","fragmentStage","primitiveTopology","colorStates","testVertexState","success","vertexShader","vsModule","fsModule","expectValidationError","createRenderPipeline","generateTestVertexShader","inputs","interfaces","body","count","input","location","type","g","test","desc","subcases","combine","fn","t","lastEmpty","vertexBuffers","i","arrayStride","attribCount","attribsPerBuffer","attribsAdded","targetCount","Math","min","length","vertexBufferIndex","testShaderLocation","vertexBufferIndexA","vertexBufferIndexB","testAttributeAtStartA","testAttributeAtStartB","shaderLocationA","shaderLocationB","vertexBufferAttributes","attributesA","attributesB","testLocation","shader","cases","expand","p","shaderBaseType","shaderType","requiredBaseType","sint","uint","snorm","unorm","float","bytesPerComponent","componentCount","formatSize","halfAlignment","floor","Set","offsetsToTest","formatInfo","limit","formats"],"mappings":"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","sourcesContent":["export const description = `vertexState validation tests.`;\n\nimport { params, pbool, poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\nimport {\n  kMaxVertexAttributes,\n  kMaxVertexBufferArrayStride,\n  kMaxVertexBuffers,\n  kVertexFormats,\n  kVertexFormatInfo,\n} from '../../capability_info.js';\n\nimport { ValidationTest } from './validation_test.js';\n\nconst VERTEX_SHADER_CODE_WITH_NO_INPUT = `\n  [[builtin(position)]] var<out> Position : vec4<f32>;\n  [[stage(vertex)]] fn main() -> void {\n    Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  }\n`;\n\nfunction addTestAttributes(\n  attributes: GPUVertexAttributeDescriptor[],\n  {\n    testAttribute,\n    testAttributeAtStart = true,\n    extraAttributeCount = 0,\n    extraAttributeSkippedLocations = [],\n  }: {\n    testAttribute?: GPUVertexAttributeDescriptor;\n    testAttributeAtStart?: boolean;\n    extraAttributeCount?: Number;\n    extraAttributeSkippedLocations?: Number[];\n  }\n) {\n  // Add a bunch of dummy attributes each with a different location such that none of the locations\n  // are in extraAttributeSkippedLocations\n  let currentLocation = 0;\n  let extraAttribsAdded = 0;\n  while (extraAttribsAdded !== extraAttributeCount) {\n    if (extraAttributeSkippedLocations.includes(currentLocation)) {\n      currentLocation++;\n      continue;\n    }\n\n    attributes.push({ format: 'float32', shaderLocation: currentLocation, offset: 0 });\n    currentLocation++;\n    extraAttribsAdded++;\n  }\n\n  // Add the test attribute at the start or the end of the attributes.\n  if (testAttribute) {\n    if (testAttributeAtStart) {\n      attributes.unshift(testAttribute);\n    } else {\n      attributes.push(testAttribute);\n    }\n  }\n}\n\nclass F extends ValidationTest {\n  getDescriptor(\n    vertexState: GPUVertexStateDescriptor,\n    vertexShaderCode: string\n  ): GPURenderPipelineDescriptor {\n    const descriptor: GPURenderPipelineDescriptor = {\n      vertexStage: {\n        module: this.device.createShaderModule({ code: vertexShaderCode }),\n        entryPoint: 'main',\n      },\n      fragmentStage: {\n        module: this.device.createShaderModule({\n          code: `\n            [[location(0)]] var<out> fragColor : vec4<f32>;\n            [[stage(fragment)]] fn main() -> void {\n              fragColor = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n              return;\n            }`,\n        }),\n        entryPoint: 'main',\n      },\n      primitiveTopology: 'triangle-list',\n      colorStates: [{ format: 'rgba8unorm' }],\n      vertexState,\n    };\n    return descriptor;\n  }\n\n  testVertexState(\n    success: boolean,\n    vertexState: GPUVertexStateDescriptor,\n    vertexShader: string = VERTEX_SHADER_CODE_WITH_NO_INPUT\n  ) {\n    const vsModule = this.device.createShaderModule({ code: vertexShader });\n    const fsModule = this.device.createShaderModule({\n      code: `\n        [[location(0)]] var<out> fragColor : vec4<f32>;\n        [[stage(fragment)]] fn main() -> void {\n          fragColor = vec4<f32>(0.0, 1.0, 0.0, 1.0);\n        }`,\n    });\n\n    this.expectValidationError(() => {\n      this.device.createRenderPipeline({\n        vertexState,\n        vertexStage: {\n          module: vsModule,\n          entryPoint: 'main',\n        },\n        fragmentStage: {\n          module: fsModule,\n          entryPoint: 'main',\n        },\n        primitiveTopology: 'triangle-list',\n        colorStates: [{ format: 'rgba8unorm' }],\n      });\n    }, !success);\n  }\n\n  generateTestVertexShader(inputs: { type: string; location: number }[]): string {\n    let interfaces = '';\n    let body = '';\n\n    let count = 0;\n    for (const input of inputs) {\n      interfaces += `[[location(${input.location})]] var<in> input${count} : ${input.type};\\n`;\n      body += `var i${count} : ${input.type} = input${count};\\n`;\n      count++;\n    }\n\n    return `\n      [[builtin(position)]] var<out> Position : vec4<f32>;\n      ${interfaces}\n      [[stage(vertex)]] fn main() -> void {\n        Position = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n        ${body}\n      }\n    `;\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('max_vertex_buffer_limit')\n  .desc(\n    `Test that only up to <maxVertexBuffers> vertex buffers are allowed.\n   - Tests with 0, 1, limits, limits + 1 vertex buffers.\n   - Tests with the last buffer having an attribute or not.\n  This also happens to test that vertex buffers with no attributes are allowed and that a vertex state with no buffers is allowed.`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('count', [0, 1, kMaxVertexBuffers, kMaxVertexBuffers + 1]))\n      .combine(pbool('lastEmpty'))\n  )\n  .fn(t => {\n    const { count, lastEmpty } = t.params;\n\n    const vertexBuffers = [];\n    for (let i = 0; i < count; i++) {\n      if (lastEmpty || i !== count - 1) {\n        vertexBuffers.push({ attributes: [], arrayStride: 0 });\n      } else {\n        vertexBuffers.push({\n          attributes: [{ format: 'float32', offset: 0, shaderLocation: 0 }],\n          arrayStride: 0,\n        } as const);\n      }\n    }\n\n    const success = count <= kMaxVertexBuffers;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('max_vertex_attribute_limit')\n  .desc(\n    `Test that only up to <maxVertexAttributes> vertex attributes are allowed.\n   - Tests with 0, 1, limit, limits + 1 vertex attribute.\n   - Tests with 0, 1, 4 attributes per buffer (with remaining attributes in the last buffer).`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('attribCount', [0, 1, kMaxVertexAttributes, kMaxVertexAttributes + 1]))\n      .combine(poptions('attribsPerBuffer', [0, 1, 4]))\n  )\n  .fn(t => {\n    const { attribCount, attribsPerBuffer } = t.params;\n\n    const vertexBuffers = [];\n\n    let attribsAdded = 0;\n    while (attribsAdded !== attribCount) {\n      // Choose how many attributes to add for this buffer. The last buffer gets all remaining attributes.\n      let targetCount = Math.min(attribCount, attribsAdded + attribsPerBuffer);\n      if (vertexBuffers.length === kMaxVertexBuffers - 1) {\n        targetCount = attribCount;\n      }\n\n      const attributes = [];\n      while (attribsAdded !== targetCount) {\n        attributes.push({ format: 'float32', offset: 0, shaderLocation: attribsAdded } as const);\n        attribsAdded++;\n      }\n\n      vertexBuffers.push({ arrayStride: 0, attributes });\n    }\n\n    const success = attribCount <= kMaxVertexAttributes;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('max_vertex_buffer_array_stride_limit')\n  .desc(\n    `Test that the vertex buffer arrayStride must be at most <maxVertexBufferArrayStride>.\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 4, 256, limit - 4, limit, limit + 4`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          4,\n          256,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride,\n          kMaxVertexBufferArrayStride + 4,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride <= kMaxVertexBufferArrayStride;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_buffer_array_stride_limit_alignment')\n  .desc(\n    `Test that the vertex buffer arrayStride must be a multiple of 4 (including 0).\n   - Test for various vertex buffer indices\n   - Test for array strides 0, 1, 2, 4, limit - 4, limit - 2, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(\n        poptions('arrayStride', [\n          0,\n          1,\n          2,\n          4,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride - 2,\n          kMaxVertexBufferArrayStride,\n        ])\n      )\n  )\n  .fn(t => {\n    const { vertexBufferIndex, arrayStride } = t.params;\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes: [] };\n\n    const success = arrayStride % 4 === 0;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_attribute_shaderLocation_limit')\n  .desc(\n    `Test shaderLocation must be less than maxVertexAttributes.\n   - Test for various vertex buffer indices\n   - Test for various amounts of attributes in that vertex buffer\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n      .combine(\n        poptions('testShaderLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes])\n      )\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testShaderLocation,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttributeDescriptor[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: testShaderLocation },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    const success = testShaderLocation < kMaxVertexAttributes;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_attribute_shaderLocation_unique')\n  .desc(\n    `Test that shaderLocation must be unique in the vertex state.\n   - Test for various pairs of buffers that contain the potentially conflicting attributes\n   - Test for the potentially conflicting attributes in various places in the buffers (with dummy attributes)\n   - Test for various shaderLocations that conflict or not`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndexA', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('vertexBufferIndexB', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(pbool('testAttributeAtStartA'))\n      .combine(pbool('testAttributeAtStartB'))\n      .combine(poptions('shaderLocationA', [0, 1, 7, kMaxVertexAttributes - 1]))\n      .combine(poptions('shaderLocationB', [0, 1, 7, kMaxVertexAttributes - 1]))\n      .combine(poptions('extraAttributeCount', [0, 4]))\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndexA,\n      vertexBufferIndexB,\n      testAttributeAtStartA,\n      testAttributeAtStartB,\n      shaderLocationA,\n      shaderLocationB,\n      extraAttributeCount,\n    } = t.params;\n\n    // Depending on the params, the vertexBuffer for A and B can be the same or different. To support\n    // both cases without code changes we treat `vertexBufferAttributes` as a map from indices to\n    // vertex buffer descriptors, with A and B potentially reusing the same JS object if they have the\n    // same index.\n    const vertexBufferAttributes = [];\n    vertexBufferAttributes[vertexBufferIndexA] = [];\n    vertexBufferAttributes[vertexBufferIndexB] = [];\n\n    // Add the dummy attributes for attribute A\n    const attributesA = vertexBufferAttributes[vertexBufferIndexA];\n    addTestAttributes(attributesA, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationA },\n      testAttributeAtStart: testAttributeAtStartA,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [shaderLocationA, shaderLocationB],\n    });\n\n    // Add attribute B. Not that attributesB can be the same object as attributesA so they end\n    // up in the same vertex buffer.\n    const attributesB = vertexBufferAttributes[vertexBufferIndexB];\n    addTestAttributes(attributesB, {\n      testAttribute: { format: 'float32', offset: 0, shaderLocation: shaderLocationB },\n      testAttributeAtStart: testAttributeAtStartB,\n    });\n\n    // Use the attributes to make the list of vertex buffers. Note that we might be setting the same vertex\n    // buffer twice, but that only happens when it is the only vertex buffer.\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndexA] = { arrayStride: 256, attributes: attributesA };\n    vertexBuffers[vertexBufferIndexB] = { arrayStride: 256, attributes: attributesB };\n\n    // Note that an empty vertex shader will be used so errors only happens because of the conflict\n    // in the vertex state.\n    const success = shaderLocationA !== shaderLocationB;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_shader_input_location_limit')\n  .desc(\n    `Test that vertex shader's input's location decoration must be less than maxVertexAttributes.\n   - Test for shaderLocation 0, 1, limit - 1, limit`\n  )\n  .subcases(() =>\n    params().combine(\n      poptions('testLocation', [0, 1, kMaxVertexAttributes - 1, kMaxVertexAttributes, -1, 2 ** 32])\n    )\n  )\n  .fn(t => {\n    const { testLocation } = t.params;\n\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testLocation,\n      },\n    ]);\n\n    const vertexBuffers = [\n      {\n        arrayStride: 512,\n        attributes: [\n          {\n            format: 'float32',\n            offset: 0,\n            shaderLocation: testLocation,\n          } as const,\n        ],\n      },\n    ];\n\n    const success = testLocation < kMaxVertexAttributes;\n    t.testVertexState(success, { vertexBuffers }, shader);\n  });\n\ng.test('vertex_shader_input_location_in_vertex_state')\n  .desc(\n    `Test that a vertex shader defined in the shader must have a corresponding attribute in the vertex state.\n       - Test for various input locations.\n       - Test for the attribute in various places in the list of vertex buffer and various places inside the vertex buffer descriptor`\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n      .combine(poptions('testShaderLocation', [0, 1, 4, 7, kMaxVertexAttributes - 1]))\n  )\n  .fn(t => {\n    const {\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n      testShaderLocation,\n    } = t.params;\n    // We have a shader using `testShaderLocation`.\n    const shader = t.generateTestVertexShader([\n      {\n        type: 'vec4<f32>',\n        location: testShaderLocation,\n      },\n    ]);\n\n    const attributes: GPUVertexAttributeDescriptor[] = [];\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride: 256, attributes };\n\n    // Fill attributes with a bunch of attributes for other locations.\n    // Using that vertex state is invalid because the vertex state doesn't contain the test location\n    addTestAttributes(attributes, {\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [testShaderLocation],\n    });\n    t.testVertexState(false, { vertexBuffers }, shader);\n\n    // Add an attribute for the test location and try again.\n    addTestAttributes(attributes, {\n      testAttribute: { format: 'float32', shaderLocation: testShaderLocation, offset: 0 },\n      testAttributeAtStart,\n    });\n    t.testVertexState(true, { vertexBuffers }, shader);\n  });\n\ng.test('vertex_shader_type_matches_attribute_format')\n  .desc(\n    `\n    Test that the vertex shader declaration must have a type compatible with the vertex format.\n     - Test for all formats.\n     - Test for all combinations of u/i/f32 with and without vectors.`\n  )\n  .cases(poptions('format', kVertexFormats))\n  .subcases(() =>\n    params()\n      .combine(poptions('shaderBaseType', ['u32', 'i32', 'f32']))\n      .expand(p => {\n        return poptions('shaderType', [\n          p.shaderBaseType,\n          `vec2<${p.shaderBaseType}>`,\n          `vec3<${p.shaderBaseType}>`,\n          `vec4<${p.shaderBaseType}>`,\n        ]);\n      })\n  )\n  .fn(t => {\n    const { format, shaderBaseType, shaderType } = t.params;\n    const shader = t.generateTestVertexShader([\n      {\n        type: shaderType,\n        location: 0,\n      },\n    ]);\n\n    const requiredBaseType = {\n      sint: 'i32',\n      uint: 'u32',\n      snorm: 'f32',\n      unorm: 'f32',\n      float: 'f32',\n    }[kVertexFormatInfo[format].type];\n\n    const success = requiredBaseType === shaderBaseType;\n    t.testVertexState(\n      success,\n      {\n        vertexBuffers: [\n          {\n            arrayStride: 0,\n            attributes: [{ offset: 0, shaderLocation: 0, format }],\n          },\n        ],\n      },\n      shader\n    );\n  });\n\ng.test('vertex_attribute_offset_alignment')\n  .desc(\n    `\n    Test that vertex attribute offsets must be aligned to the format's component byte size.\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .cases(\n    params()\n      .combine(poptions('format', kVertexFormats))\n      .combine(poptions('arrayStride', [256, kMaxVertexBufferArrayStride]))\n      .expand(p => {\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[p.format];\n        const formatSize = bytesPerComponent * componentCount;\n        const halfAlignment = Math.floor(bytesPerComponent / 2);\n\n        return poptions(\n          'offset',\n          new Set([\n            0,\n            halfAlignment,\n            bytesPerComponent,\n            p.arrayStride - formatSize,\n            p.arrayStride - formatSize - halfAlignment,\n          ])\n        );\n      })\n  )\n  .subcases(() =>\n    params()\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttributeDescriptor[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const success = offset % kVertexFormatInfo[format].bytesPerComponent === 0;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('vertex_attribute_contained_in_stride')\n  .desc(\n    `\n    Test that vertex attribute [offset, offset + formatSize) must be contained in the arrayStride if arrayStride is not 0:\n    - Test for all formats.\n    - Test for various arrayStrides and offsets within that stride\n    - Test for various vertex buffer indices\n    - Test for various amounts of attributes in that vertex buffer`\n  )\n  .cases(poptions('format', kVertexFormats))\n  .subcases(({ format }) =>\n    params()\n      .combine(\n        poptions('arrayStride', [\n          0,\n          256,\n          kMaxVertexBufferArrayStride - 4,\n          kMaxVertexBufferArrayStride,\n        ])\n      )\n      .expand(p => {\n        // Compute a bunch of test offsets to test.\n        const { bytesPerComponent, componentCount } = kVertexFormatInfo[format];\n        const formatSize = bytesPerComponent * componentCount;\n        const offsetsToTest = [0, bytesPerComponent];\n\n        // arrayStride = 0 is a special case because for the offset validation it acts the same\n        // as arrayStride = kMaxVertexBufferArrayStride. We branch so as to avoid adding negative\n        // offsets that would cause an IDL exception to be thrown instead of a validation error.\n        if (p.arrayStride === 0) {\n          offsetsToTest.push(kMaxVertexBufferArrayStride - formatSize);\n          offsetsToTest.push(kMaxVertexBufferArrayStride - formatSize + bytesPerComponent);\n        } else {\n          offsetsToTest.push(p.arrayStride - formatSize);\n          offsetsToTest.push(p.arrayStride - formatSize + bytesPerComponent);\n        }\n\n        return poptions('offset', offsetsToTest);\n      })\n      .combine(poptions('vertexBufferIndex', [0, 1, kMaxVertexBuffers - 1]))\n      .combine(poptions('extraAttributeCount', [0, 1, kMaxVertexAttributes - 1]))\n      .combine(pbool('testAttributeAtStart'))\n  )\n  .fn(t => {\n    const {\n      format,\n      arrayStride,\n      offset,\n      vertexBufferIndex,\n      extraAttributeCount,\n      testAttributeAtStart,\n    } = t.params;\n\n    const attributes: GPUVertexAttributeDescriptor[] = [];\n    addTestAttributes(attributes, {\n      testAttribute: { format, offset, shaderLocation: 0 },\n      testAttributeAtStart,\n      extraAttributeCount,\n      extraAttributeSkippedLocations: [0],\n    });\n\n    const vertexBuffers = [];\n    vertexBuffers[vertexBufferIndex] = { arrayStride, attributes };\n\n    const formatInfo = kVertexFormatInfo[format];\n    const formatSize = formatInfo.bytesPerComponent * formatInfo.componentCount;\n    const limit = arrayStride === 0 ? kMaxVertexBufferArrayStride : arrayStride;\n\n    const success = offset + formatSize <= limit;\n    t.testVertexState(success, { vertexBuffers });\n  });\n\ng.test('many_attributes_overlapping')\n  .desc(`Test that it is valid to have many vertex attributes overlap`)\n  .fn(async t => {\n    // Create many attributes, each of them intersects with at least 3 others.\n    const attributes = [];\n    const formats = ['float32x4', 'uint32x4', 'sint32x4'] as const;\n    for (let i = 0; i < kMaxVertexAttributes; i++) {\n      attributes.push({ format: formats[i % 3], offset: i * 4, shaderLocation: i } as const);\n    }\n\n    t.testVertexState(true, {\n      vertexBuffers: [{ arrayStride: 0, attributes }],\n    });\n  });\n"],"file":"vertex_state.spec.js"}